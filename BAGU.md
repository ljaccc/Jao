# TCP
- **没有listen/accept，为什么还能建立连接？**
  - 每一个socket执行listen时，内核都会自动创建一个半连接队列和全连接队列。
  - 第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。
  - accept方法只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎毫无关系。
  - 出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了哈希表，而全连接队列本质是链表。
  - 全连接队列满了，再来第三次握手也会丢弃，此时如果tcp_abort_on_overflow=1，还会直接发RST给客户端。
  - 半连接队列满了，可能是因为受到了SYN Flood攻击，可以设置tcp_syncookies，绕开半连接队列。
  - 客户端没有半连接队列和全连接队列，但有一个全局hash，可以通过它实现自连接或TCP同时打开。
- **TCP 重传、滑动窗口、流量控制、拥塞控制**
  - 快速重传
    - 当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
    - 丢失报文后，后续传送的报文得到的ACK都会是同一个。
    - 只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。
  - SACK选择性重传
    -  在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，
       这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。
  - Duplicate SACK
    - 使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。解决接收方接收到了数据报文，但ACK确认报文丢失。
    - 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
    - 可以知道是不是「发送方」的数据包被网络延迟了;
    - 可以知道网络中是不是把「发送方」的数据包给复制了。
   
  - **滑动窗口**
    - 窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。
   
  - **流量控制**
    - TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。
    - **TCP 是如何解决窗口关闭时，潜在的死锁现象呢？**
        - 只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，
          而对方在确认这个探测报文时，给出自己现在的接收窗口大小。
    - **糊涂窗口综合症**
      - 如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节。发送一次开销大，资源浪费。
        - 让接收方不通告小窗口：
          - 当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，
            也就阻止了发送方再发数据过来。
            等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。
        - 让发送方避免发送小数据：
          - 使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：
            条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS；
            条件二：收到之前发送数据的 ack 回包；
            只要上面两个条件都不满足，发送方一直在囤积数据，直到满足上面的发送条件。
      - **接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症。**
     
  - **拥塞控制cwnd**
    - 发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。
    - 发送窗口的值是拥塞窗口和接收窗口中的最小值。
    - 算法：
      - 慢启动
        - 当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。指数增长
      - 拥塞避免
        - 当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，
          于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。
      - 拥塞发生
        - 超时重传
        - 快速重传
      - 快速恢复
        - 快速重传和快速恢复算法一般同时使用。

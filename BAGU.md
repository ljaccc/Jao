# TCP
- **没有listen/accept，为什么还能建立连接？**
  - 每一个socket执行listen时，内核都会自动创建一个半连接队列和全连接队列。
  - 第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。
  - accept方法只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎毫无关系。
  - 出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了哈希表，而全连接队列本质是链表。
  - 全连接队列满了，再来第三次握手也会丢弃，此时如果tcp_abort_on_overflow=1，还会直接发RST给客户端。
  - 半连接队列满了，可能是因为受到了SYN Flood攻击，可以设置tcp_syncookies，绕开半连接队列。
  - 客户端没有半连接队列和全连接队列，但有一个全局hash，可以通过它实现自连接或TCP同时打开。
- **TCP 重传、滑动窗口、流量控制、拥塞控制**
  - 快速重传
    - 当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
    - 丢失报文后，后续传送的报文得到的ACK都会是同一个。
    - 只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。
  - SACK选择性重传
    -  在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，
       这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。
  - Duplicate SACK
    - 使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。解决接收方接收到了数据报文，但ACK确认报文丢失。
    - 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
    - 可以知道是不是「发送方」的数据包被网络延迟了;
    - 可以知道网络中是不是把「发送方」的数据包给复制了。
  
